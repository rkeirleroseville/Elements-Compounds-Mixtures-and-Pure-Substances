<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Particle Diagram Quiz — Mixtures & Pure Substances</title>
  <style>
    :root{
      --bg:#0b1020;           /* deep navy */
      --panel:#101a36;
      --ink:#e8ecf8;
      --muted:#9aa6d1;
      --accent:#63b3ff;
      --ok:#58e06c;
      --bad:#ff6b6b;
      --btn:#0b1430;
      --btn-border:#2c3f86;
      --btn-hover:#3a56b1;
      --btn-correct:#124d24;
      --btn-incorrect:#5a1c1c;
      --btn-correct-border:#2f8f46;
      --btn-incorrect-border:#9e2a2a;
      --chip:#17224a;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 20% -10%, #18275c 0%, transparent 60%),
                  radial-gradient(900px 500px at 110% 10%, #1a2858 0%, transparent 65%),
                  var(--bg);
      color:var(--ink);
      display:grid; grid-template-rows:auto auto 1fr auto; gap:12px; padding:14px;
    }
    header{display:flex; align-items:center; gap:12px; justify-content:space-between}
    h1{font-size:18px; margin:0}
    .panel{background:linear-gradient(180deg, #0f1733 0%, #0d1634 100%); border:1px solid #22306a; border-radius:16px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.25)}

    /* Controls */
    .controls{display:grid; gap:10px}
    .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    button{cursor:pointer; background:var(--btn); border:1px solid var(--btn-border); color:var(--ink); padding:10px 14px; border-radius:12px; font-weight:700; transition:.15s}
    button:hover{border-color:var(--btn-hover)}
    .btn-accent{background:linear-gradient(90deg, #1c6fe8, #20a5e8); border:0}

    /* Answer button states */
    .answer-btn{min-width:220px}
    .answer-btn.correct{background:var(--btn-correct); border-color:var(--btn-correct-border)}
    .answer-btn.incorrect{background:var(--btn-incorrect); border-color:var(--btn-incorrect-border)}
    .answer-btn:disabled{opacity:0.9}

    .status{min-height:24px; font-size:14px; color:var(--muted)}
    .status.ok{color:var(--ok)}
    .status.bad{color:var(--bad)}

    .chips{display:flex; gap:8px; flex-wrap:wrap}
    .chip{background:var(--chip); border:1px solid #2a3b80; color:#cfe0ff; border-radius:999px; padding:6px 10px; font-size:12px}

    .stage{display:grid; grid-template-columns:1fr; gap:12px}
    .canvas-wrap{position:relative}
    canvas{width:100%; height:100%; display:block; border-radius:16px; background:#0a0f22; border:1px solid #1a254d}
    .footer{font-size:12px; color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <h1>Particle Diagram Quiz</h1>
    <div class="chips" id="scoreStrip">
      <span class="chip" id="scoreChip">Score: 0</span>
      <span class="chip" id="streakChip">Streak: 0</span>
    </div>
  </header>

  <section class="panel controls">
    <div class="row">
      <button id="btnGenerate" class="btn-accent">Generate</button>
      <div id="answerHost" class="row" style="flex:1 1 auto"></div>
    </div>
    <div id="status" class="status">Press <strong>Generate</strong> to create a diagram.</div>
  </section>

  <section class="panel stage">
    <div class="canvas-wrap">
      <canvas id="scene" width="1200" height="800" aria-label="Particle diagram canvas"></canvas>
    </div>
  </section>

  <div class="footer">Rules: elemental molecule = two identical touching circles; compound = 2+ touching circles with at least one different colour. Same colour ⇒ same size within an image. Compounds use a consistent prototype and shape (linear or V) within each image; in “Mixture of compounds”, two distinct, internally consistent types may appear. Global spacing prevents unbonded atoms from appearing bonded.</div>

  <script>
    // ================== Hidden config ==================
    const HIDDEN_COUNT = 15;                 // placements (atoms or molecules)
    const LOOSE_PACKING_PAD = 28;            // base pad for loose packing
    const GLOBAL_GAP_FACTOR = 0.35;          // extra separation between different particles

    const CATEGORIES = [
      'Mixture of different elements',
      'Mixture of an element and a compound',
      'Mixture of compounds',
      'Pure substance of an element',
      'Pure substance of a compound'
    ];

    // Step-1 and Step-2 labels
    const STEP1 = ['Mixture','Pure substance'];
    const STEP2_MAP = {
      'Mixture': ['Mixture of different elements','Mixture of an element and a compound','Mixture of compounds'],
      'Pure substance': ['Pure substance of an element','Pure substance of a compound']
    };

    // ================== RNG ==================
    function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
    const rnd = { _rng: mulberry32(Math.floor(Math.random()*1e9)), next(){return this._rng();}, range(a,b){return a+(b-a)*this.next();}, int(a,b){return Math.floor(this.range(a,b+1));}, pick(arr){return arr[this.int(0,arr.length-1)]}, shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=this.int(0,i); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; } };

    // ================== Canvas ==================
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){
      const wrap = canvas.parentElement.getBoundingClientRect();
      const margin = 16; canvas.width = Math.max(600, Math.floor(wrap.width)-margin*2); canvas.height = Math.max(380, Math.floor(wrap.height)-margin*2);
    }
    window.addEventListener('resize', ()=>{ resizeCanvas(); /* draw-once */ });

    let placed = []; // {x,y,r,color}
    let imageAnswer = null; // correct full category for current image

    // ================== Colours & sizes ==================
    const palette = [ '#ff6b6b','#6bc8ff','#7cff6b','#ffd56b','#c86bff','#6bffc8','#ff9df2','#a9ff6b','#ffb36b','#6b9bff','#9fffd0','#e0ff6b' ];
    function makeColourSizes(meanR){
      const colourR = new Map();
      return function getSize(color){
        if(!colourR.has(color)){
          const r = Math.max(4, meanR * (0.85 + rnd.range(0,0.3))); // lock per-colour
          colourR.set(color, r);
        }
        return colourR.get(color);
      }
    }

    // ================== Geometry ==================
    function circlesTooClose(a,b){ const dx=a.x-b.x, dy=a.y-b.y; const rr=(a.r+b.r)*(1+GLOBAL_GAP_FACTOR); return dx*dx+dy*dy < rr*rr - 1e-3; }
    function inBounds(x,y,r,w,h){ return (x-r>=4 && y-r>=4 && x+r<=w-4 && y+r<=h-4); }
    function drawCircle(c){
      const {x,y,r,color} = c; const g = ctx.createRadialGradient(x-r*0.4, y-r*0.6, r*0.2, x, y, r);
      g.addColorStop(0, '#ffffff'); g.addColorStop(0.05, color); g.addColorStop(1, color);
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.25)'; ctx.lineWidth = 1; ctx.stroke();
    }
    function tryPlace(atoms, tries=600){
      const W=canvas.width, H=canvas.height; const pad=LOOSE_PACKING_PAD;
      while(tries-- > 0){
        const ax = rnd.range(pad, W-pad), ay = rnd.range(pad, H-pad);
        const theta = rnd.range(0, Math.PI*2); const cos=Math.cos(theta), sin=Math.sin(theta);
        let ok=true; const abs=[];
        for(const a of atoms){
          const x = ax + (a.rel.x*cos - a.rel.y*sin);
          const y = ay + (a.rel.x*sin + a.rel.y*cos);
          if(!inBounds(x,y,a.r,W,H)){ok=false;break;}
          for(const p of placed){ if(circlesTooClose({x,y,r:a.r},{x:p.x,y:p.y,r:p.r})){ ok=false; break; } }
          if(!ok) break; abs.push({x,y,r:a.r,color:a.color});
        }
        if(ok){ abs.forEach(c=>{ placed.push(c); drawCircle(c); }); return true; }
      }
      return false;
    }

    // ================== Builders (compounds with central atom) ==================
    function atom(r,color){ return {r, color, rel:{x:0,y:0}}; }
    function buildMonatomic(meanR, getSize, color){ return [ atom(getSize(color), color) ]; }
    function buildDiatomic(meanR, getSize, color){ const r=getSize(color); const a=atom(r,color), b=atom(r,color); b.rel={x:r+r,y:0}; return [a,b]; }

    function buildCompound(proto, meanR, getSize, A, B, shape){
      // shape: { mode:'linear'|'v', angle:number }
      const mode = shape?.mode || 'linear';
      const ANG = shape?.angle ?? Math.PI/12; // ~15°
      if(proto==='AB'){
        const ra=getSize(A), rb=getSize(B); const a=atom(ra,A), b=atom(rb,B); b.rel={x:ra+rb,y:0}; return [a,b];
      }
      if(proto==='AB2'){
        const ra=getSize(A), rb=getSize(B); const aC=atom(ra,A); const d=ra+rb; let b1,b2;
        if(mode==='linear'){ b1=atom(rb,B); b1.rel={x:d,y:0}; b2=atom(rb,B); b2.rel={x:-d,y:0}; }
        else { const c=Math.cos(ANG), s=Math.sin(ANG); b1=atom(rb,B); b1.rel={x:d*c,y:d*s}; b2=atom(rb,B); b2.rel={x:d*c,y:-d*s}; }
        return [aC,b1,b2];
      }
      // A2B (B central)
      const ra=getSize(A), rb=getSize(B); const bC=atom(rb,B); const d=ra+rb; let a1,a2;
      if(mode==='linear'){ a1=atom(ra,A); a1.rel={x:d,y:0}; a2=atom(ra,A); a2.rel={x:-d,y:0}; }
      else { const c=Math.cos(ANG), s=Math.sin(ANG); a1=atom(ra,A); a1.rel={x:d*c,y:d*s}; a2=atom(ra,A); a2.rel={x:d*c,y:-d*s}; }
      return [bC,a1,a2];
    }

    // ================== Generation ==================
    function generateScene(){
      resizeCanvas(); ctx.clearRect(0,0,canvas.width,canvas.height); placed.length=0;
      const meanR = 14; const colours = rnd.shuffle(palette.slice()); const getSize = makeColourSizes(meanR);
      const category = rnd.pick(CATEGORIES);
      function placeMany(builder, n){ for(let i=0;i<n;i++){ tryPlace(builder()); } }
      let remaining = HIDDEN_COUNT;

      if(category === 'Mixture of different elements'){
        const nTypes = rnd.pick([2,3]); const split = Array(nTypes).fill(0).map(()=>1); for(let i=0;i<remaining-nTypes;i++){ split[rnd.int(0,nTypes-1)]++; }
        for(let t=0;t<nTypes;t++){ const color = colours[t]; const asDiatomic = rnd.next()<0.5; placeMany(()=> asDiatomic? buildDiatomic(meanR,getSize,color): buildMonatomic(meanR,getSize,color), split[t]); }
      }
      else if(category === 'Mixture of an element and a compound'){
        const colorE = colours[0]; const [A,B] = [colours[1], colours[2]]; const proto = rnd.pick(['AB','AB2','A2B']);
        const shape = { mode: (rnd.next()<0.5?'linear':'v'), angle: rnd.range(Math.PI/16, Math.PI/6) };
        const nCompound = Math.floor(remaining*0.5); const nElement = remaining - nCompound; const elIsDiatomic = rnd.next()<0.5;
        placeMany(()=> elIsDiatomic? buildDiatomic(meanR,getSize,colorE): buildMonatomic(meanR,getSize,colorE), nElement);
        placeMany(()=> buildCompound(proto, meanR,getSize,A,B, shape), nCompound);
      }
      else if(category === 'Mixture of compounds'){
        const [A,B,C,D] = colours.slice(0,4); let proto1 = rnd.pick(['AB','AB2','A2B']); let proto2 = rnd.pick(['AB','AB2','A2B']); if(proto2===proto1){ proto2 = rnd.pick(['AB','AB2','A2B'].filter(p=>p!==proto1)); }
        const shape1 = { mode: (rnd.next()<0.5?'linear':'v'), angle: rnd.range(Math.PI/16, Math.PI/6) };
        const shape2 = { mode: (rnd.next()<0.5?'linear':'v'), angle: rnd.range(Math.PI/16, Math.PI/6) };
        const n1 = Math.floor(remaining/2); const n2 = remaining - n1;
        placeMany(()=> buildCompound(proto1, meanR,getSize,A,B, shape1), n1);
        placeMany(()=> buildCompound(proto2, meanR,getSize,C,D, shape2), n2);
      }
      else if(category === 'Pure substance of an element'){
        const color = colours[0]; const asDiatomic = rnd.next()<0.5; placeMany(()=> asDiatomic? buildDiatomic(meanR,getSize,color): buildMonatomic(meanR,getSize,color), remaining);
      }
      else if(category === 'Pure substance of a compound'){
        const [A,B] = [colours[0], colours[1]]; const proto = rnd.pick(['AB','AB2','A2B']); const shape = { mode: (rnd.next()<0.5?'linear':'v'), angle: rnd.range(Math.PI/16, Math.PI/6) };
        placeMany(()=> buildCompound(proto, meanR,getSize,A,B, shape), remaining);
      }
      imageAnswer = category; // store correct answer
    }

    // ================== Quiz state & scoring ==================
    let score = 0, streak = 0;

    const statusEl = document.getElementById('status');
    const answerHost = document.getElementById('answerHost');
    const scoreChip = document.getElementById('scoreChip');
    const streakChip = document.getElementById('streakChip');

    function setStatus(msg, cls){ statusEl.className='status'+(cls?(' '+cls):''); statusEl.innerHTML = msg; }
    function refreshScore(){ scoreChip.textContent = `Score: ${score}`; streakChip.textContent = `Streak: ${streak}`; }

    function clearAnswers(){ answerHost.querySelectorAll('button').forEach(b=>{ b.classList.remove('correct','incorrect'); b.disabled=false; }); }

    function correctStep1For(category){ return category.startsWith('Mixture') ? 'Mixture' : 'Pure substance'; }

    // Toast + tiny bell using Web Audio API (no external asset)
    function ringBell(){
      try{
        const ctxA = new (window.AudioContext||window.webkitAudioContext)();
        const o1 = ctxA.createOscillator(); const g = ctxA.createGain();
        o1.type='sine'; o1.frequency.value = 1240; // bright ding
        const o2 = ctxA.createOscillator(); o2.type='sine'; o2.frequency.value = 1860;
        const mix = ctxA.createGain(); mix.gain.value = 0.15; // quiet
        const env = ctxA.createGain(); env.gain.value = 0;
        o1.connect(mix); o2.connect(mix); mix.connect(env); env.connect(ctxA.destination);
        const now = ctxA.currentTime;
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.6, now+0.01);
        env.gain.exponentialRampToValueAtTime(0.0001, now+0.35);
        o1.start(now); o2.start(now);
        o1.stop(now+0.4); o2.stop(now+0.4);
        setTimeout(()=>ctxA.close(), 500);
      }catch(e){ /* ignore */ }
    }

    function toast(msg, sound=false){
      const t=document.createElement('div');
      t.textContent=msg;
      t.style.position='fixed'; t.style.left='50%'; t.style.bottom='24px'; t.style.transform='translateX(-50%)';
      t.style.padding='10px 14px'; t.style.background='rgba(20,30,70,0.95)'; t.style.border='1px solid #3f60de'; t.style.borderRadius='10px'; t.style.color='#e8ecf8'; t.style.zIndex=9999;
      document.body.appendChild(t);
      if(sound) ringBell();
      setTimeout(()=>{ t.style.transition='opacity .4s ease'; t.style.opacity='0'; setTimeout(()=> t.remove(), 400); }, 1200);
    }

    function renderTwoStep(){
      answerHost.innerHTML = '';
      // Step 1 buttons
      const step1Wrap = document.createElement('div'); step1Wrap.className='row';
      const s1Btns = STEP1.map(lbl=>{ const b=document.createElement('button'); b.textContent=lbl; b.className='answer-btn'; return b; });
      s1Btns.forEach(b=> step1Wrap.appendChild(b));
      answerHost.appendChild(step1Wrap);

      // Step 2 container
      const step2Wrap = document.createElement('div'); step2Wrap.className='row'; step2Wrap.style.opacity=0.5; step2Wrap.style.pointerEvents='none';
      answerHost.appendChild(step2Wrap);

      // Build step 2 buttons dynamically after step1 pick
      function enableStep2(forLabel){
        step2Wrap.innerHTML = ''; step2Wrap.style.opacity=1; step2Wrap.style.pointerEvents='auto';
        const labels = STEP2_MAP[forLabel]; const step2Buttons = labels.map(lbl=>{ const b=document.createElement('button'); b.textContent=lbl; b.className='answer-btn'; step2Wrap.appendChild(b); return b; });
        // Wire step2
        step2Buttons.forEach(btn=>{
          btn.addEventListener('click', ()=>{
            step2Buttons.forEach(b=> b.disabled=true);
            const correct = (btn.textContent===imageAnswer);
            if(correct){
              btn.classList.add('correct');
              streak += 1; score += 1; refreshScore(); setStatus(`✅ Correct!`, 'ok');
              if(streak===5) toast('Now go for 10 in a row!', true);
              if(streak===10) toast('Oh yeh!', true);
            } else {
              btn.classList.add('incorrect');
              step2Buttons.forEach(b=>{ if(b.textContent===imageAnswer){ b.classList.add('correct'); }});
              setStatus(`❌ Not quite.`, 'bad');
              streak = 0; refreshScore();
            }
          });
        });
      }

      // Wire step1
      s1Btns.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          s1Btns.forEach(b=> b.disabled=true);
          const correctLabel = correctStep1For(imageAnswer);
          if(btn.textContent===correctLabel){ btn.classList.add('correct'); setStatus('✅ Step 1 correct. Now choose the specific type.', 'ok'); enableStep2(correctLabel); }
          else { btn.classList.add('incorrect'); s1Btns.forEach(b=>{ if(b.textContent===correctLabel){ b.classList.add('correct'); }}); setStatus('❌ Step 1 not quite. Now choose the specific type.', 'bad'); enableStep2(correctLabel); }
        });
      });
    }

    function renderAnswers(){ renderTwoStep(); }

    // ================== Controls wiring ==================
    document.getElementById('btnGenerate').addEventListener('click', ()=>{
      setStatus('A new diagram was generated. Classify it!', '');
      clearAnswers(); generateScene(); renderAnswers();
    });

    // Init
    resizeCanvas(); refreshScore(); renderAnswers();
  </script>
</body>
</html>
